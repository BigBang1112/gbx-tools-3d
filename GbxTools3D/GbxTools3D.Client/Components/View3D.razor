@rendermode InteractiveWebAssembly
@implements IAsyncDisposable
@using System.Runtime.InteropServices.JavaScript
@using GBX.NET
@using GBX.NET.Engines.Game
@using GbxTools3D.Client.Dtos
@using GbxTools3D.Client.Extensions
@using GbxTools3D.Client.Models
@using GbxTools3D.Client.Modules
@inject HttpClient Http

@if (RendererInfo.IsInteractive)
{
    <div class="canvas-wrap">
        <canvas></canvas>
    </div>
}
else
{
    <Loader></Loader>
}

@code {
    private JSObject? rendererModule;
    private JSObject? sceneModule;
    private JSObject? cameraModule;
    private JSObject? solidModule;
    private JSObject? materialModule;

    private JSObject? renderer;
    private Scene? scene;
    private Camera? camera;

    private bool contentLoading;
    private bool contentLoaded;

    [Parameter]
    public CGameCtnChallenge? Map { get; set; }

    private Dictionary<string, BlockInfoDto>? blockInfos;
    private Dictionary<Int3, DecorationSizeDto>? decorations;
    private Dictionary<string, MaterialDto>? materials;

    private CancellationTokenSource cts = new();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!RendererInfo.IsInteractive)
        {
            return;
        }

        if (firstRender)
        {
            await LoadSceneAsync(cts.Token);
        }

        await TryLoadMapAsync(cts.Token);
    }

    private async Task LoadSceneAsync(CancellationToken cancellationToken)
    {
        rendererModule = await JSHost.ImportAsync(nameof(Renderer), "../js/renderer.js", cancellationToken);
        sceneModule = await JSHost.ImportAsync(nameof(Scene), "../js/scene.js", cancellationToken);
        cameraModule = await JSHost.ImportAsync(nameof(Camera), "../js/camera.js", cancellationToken);

        renderer = Renderer.Create();
        scene = new Scene();
        camera = new Camera();
        Renderer.Camera = camera;
        Renderer.Scene = scene;
    }

    public async Task<bool> TryLoadMapAsync(CancellationToken cancellationToken = default)
    {
        if (Map is null || camera is null || renderer is null || contentLoading || contentLoaded)
        {
            return false;
        }

        contentLoading = true;

        var blockSize = Map.Collection.GetValueOrDefault().GetBlockSize();
        var center = new Vec3(Map.Size.X * blockSize.X / 2f, /*baseHeight * blockSize.Y*/0, Map.Size.Z * blockSize.Z / 2f - Map.Size.Z * blockSize.Z * 0.15f);
        camera.Position = new Vec3(center.X, Map.Size.Z * 0.5f * blockSize.Z, 0);
        camera.CreateMapControls(renderer, center);

        using var blockInfosTask = Http.GetAsync($"/api/blocks/TMF/{Map.Collection}", cancellationToken);
        using var decorationTask = Http.GetAsync($"/api/decorations/TMF/{Map.Collection}", cancellationToken);
        using var materialTask = Http.GetAsync($"/api/materials/TMF", cancellationToken);

        using var blockInfosResponse = await blockInfosTask;
        using var decorationResponse = await decorationTask;
        using var materialResponse = await materialTask;

        if (!blockInfosResponse.IsSuccessStatusCode)
        {
            // show note message that user has to wait, if the block list isnt available yet
            return contentLoading = false;
        }

        blockInfos = (await blockInfosResponse.Content.ReadFromJsonAsync(AppClientJsonContext.Default.ListBlockInfoDto, cancellationToken))?
            .ToDictionary(x => x.Name) ?? [];

        if (materialResponse.IsSuccessStatusCode)
        {
            materials = await materialResponse.Content.ReadFromJsonAsync(AppClientJsonContext.Default.DictionaryStringMaterialDto, cancellationToken);
        }

        solidModule = await JSHost.ImportAsync(nameof(Solid), "../js/solid.js", cancellationToken);
        materialModule = await JSHost.ImportAsync(nameof(Material), "../js/material.js", cancellationToken);

        var baseHeight = 5;

        if (decorationResponse.IsSuccessStatusCode)
        {
            decorations = (await decorationResponse.Content.ReadFromJsonAsync(AppClientJsonContext.Default.ListDecorationSizeDto, cancellationToken))?
                .ToDictionary(x => x.Size);

            if (decorations?.TryGetValue(Map.Size, out var decoSize) == true)
            {
                var deco = decoSize.Decorations
                    .FirstOrDefault(x => x.Name == Map.Decoration.Id);

                baseHeight = decoSize.BaseHeight;
                var size = $"{Map.Size.X}x{Map.Size.Y}x{Map.Size.Z}";

                var tasks = new Dictionary<Task<HttpResponseMessage>, Iso4>();

                foreach (var sceneObject in decoSize.Scene.Where(x => x.Solid is not null))
                {
                    if (Path.GetFileNameWithoutExtension(sceneObject.Solid)?.Contains("FarClip") == true)
                    {
                        continue;
                    }

                    var hash = $"GbxTools3D|Decoration|TMF|{Map.Collection}|{size}|{sceneObject.Solid}|Je te hais".Hash();

                    tasks.Add(Http.GetAsync($"/api/mesh/{hash}", cancellationToken), sceneObject.Location);
                }

                await foreach (var meshResponseTask in Task.WhenEach(tasks.Keys).WithCancellation(cancellationToken))
                {
                    using var meshResponse = await meshResponseTask;

                    if (!meshResponse.IsSuccessStatusCode)
                    {
                        continue;
                    }

                    await using var stream = await meshResponse.Content.ReadAsStreamAsync(cancellationToken);
                    var solid = await Solid.ParseAsync(stream, materials, expectedMeshCount: null, receiveShadow: false, castShadow: false);
                    solid.Location = tasks[meshResponseTask];
                    scene?.Add(solid);
                }
            }
        }

        var coveredZoneBlocks = GetCoveredZoneBlocks().ToHashSet();

        var baseZoneBlock = blockInfos.Values.FirstOrDefault(x => x.IsDefaultZone);
        var baseZoneBlocks = GetBaseZoneBlocks(baseZoneBlock, baseHeight);

        var uniqueBlockVariants = Map.GetBlocks()
            .Where(x => !x.IsClip && !coveredZoneBlocks.Contains(x))
            .Concat(baseZoneBlocks)
            .ToLookup(x => new UniqueVariant(x.Name, x.IsGround, x.Variant, x.SubVariant));

        var responseTasks = new Dictionary<UniqueVariant, Task<HttpResponseMessage>>();

        var counter = 0;
        foreach (var uniqueGroup in uniqueBlockVariants)
        {
            var (name, isGround, variant, subVariant) = uniqueGroup.Key;

            var hash = $"GbxTools3D|Solid|TMF|{name}|{isGround}MyGuy|{variant}|{subVariant}|PleaseDontAbuseThisThankYou:*".Hash();

            responseTasks.Add(uniqueGroup.Key, Http.GetAsync($"/api/mesh/{hash}", cancellationToken));

            if (counter > 20)
            {
                await Task.Delay(20, cancellationToken);
                counter = 0;
            }

            await ProcessResponses(responseTasks, maxRequestsToProcess: 10, uniqueBlockVariants, Map, cancellationToken);

            counter++;
        }

        while (responseTasks.Count > 0)
        {
            await Task.Delay(20, cancellationToken);
            await ProcessResponses(responseTasks, maxRequestsToProcess: null, uniqueBlockVariants, Map, cancellationToken);
        }

        return contentLoaded = true;
    }

    private async Task ProcessResponses(
        Dictionary<UniqueVariant, Task<HttpResponseMessage>> responseTasks,
        int? maxRequestsToProcess,
        ILookup<UniqueVariant, CGameCtnBlock> uniqueBlockVariantLookup,
        CGameCtnChallenge map,
        CancellationToken cancellationToken)
    {
        var tasksToRemove = new List<UniqueVariant>();

        foreach (var (variant, task) in responseTasks.Where(task => task.Value.IsCompleted))
        {
            using var response = await task;

            if (response.IsSuccessStatusCode)
            {
                await using var stream = await response.Content.ReadAsStreamAsync(cancellationToken);

                var expectedCount = uniqueBlockVariantLookup[variant].Count();
                var solid = await Solid.ParseAsync(stream, materials, expectedCount);

                PlaceBlocks(solid, variant, uniqueBlockVariantLookup[variant], map.Collection.GetValueOrDefault().GetBlockSize());
            }

            tasksToRemove.Add(variant);

            if (maxRequestsToProcess.HasValue && tasksToRemove.Count >= maxRequestsToProcess)
            {
                break;
            }
        }

        foreach (var variant in tasksToRemove)
        {
            responseTasks[variant].Dispose();
            responseTasks.Remove(variant);
        }
    }

    private void PlaceBlocks(Solid solid, UniqueVariant variant, IEnumerable<CGameCtnBlock> blocks, Int3 blockSize)
    {
        if (scene is null)
        {
            return;
        }

        var blockCoordSize = new Int3(1, 1, 1);
        var height = 0;

        if (blockInfos?.TryGetValue(variant.Name, out var blockInfo) == true)
        {
            var airUnits = blockInfo.AirUnits;
            var groundUnits = blockInfo.GroundUnits;
            blockCoordSize = variant.IsGround
                ? (groundUnits.Length > 1 ? new Int3(
                    groundUnits.Max(unit => unit.Offset.X) + 1, 
                    groundUnits.Max(unit => unit.Offset.Y) + 1, 
                    groundUnits.Max(unit => unit.Offset.Z) + 1) : blockCoordSize)
                : (airUnits.Length > 1 ? new Int3(
                    airUnits.Max(unit => unit.Offset.X) + 1,
                    airUnits.Max(unit => unit.Offset.Y) + 1, 
                    airUnits.Max(unit => unit.Offset.Z) + 1) : blockCoordSize);
            height = blockInfo.Height ?? 0;
        }

        var instanceInfos = new List<JSObject>();

        foreach (var block in blocks)
        {
            var actualCoord = block.Coord + block.Direction switch
            {
                Direction.North => (0, 0, 0),
                Direction.East => (blockCoordSize.Z, 0, 0),
                Direction.South => (blockCoordSize.X, 0, blockCoordSize.Z),
                Direction.West => (0, 0, blockCoordSize.X),
                _ => throw new ArgumentException("Invalid block direction")
            };

            var instanceInfo = Solid.GetInstanceInfoFromBlock((actualCoord + (0, -height, 0)) * blockSize, block.Direction);

            instanceInfos.Add(instanceInfo);
        }

        solid.Instantiate(instanceInfos.ToArray());
        scene.Add(solid);
    }

    private IEnumerable<CGameCtnBlock> GetCoveredZoneBlocks()
    {
        if (Map is null || blockInfos is null)
        {
            yield break;
        }

        const bool isManiaPlanet = false;
        var groundPositions = new List<Int3>();

        foreach (var block in Map.GetBlocks())
        {
            if (!blockInfos.TryGetValue(block.Name, out var blockInfo) || blockInfo.Height.HasValue)
            {
                continue;
            }

            var units = block.IsGround ? blockInfo.GroundUnits : blockInfo.AirUnits;

            if (units.Length == 1)
            {
                groundPositions.Add(block.Coord);
                continue;
            }

            Span<Int3> rotatedUnits = stackalloc Int3[units.Length];

            // Determine minimum X and Z after rotation.
            var minX = int.MaxValue;
            var minZ = int.MaxValue;
            for (int i = 0; i < units.Length; i++)
            {
                var rotated = RotateUnit(units[i].Offset, block.Direction);
                rotatedUnits[i] = rotated;
                if (rotated.X < minX) minX = rotated.X;
                if (rotated.Z < minZ) minZ = rotated.Z;
            }

            // Adjust positions so the minimum X and Z become 0.
            foreach (var rotated in rotatedUnits)
            {
                groundPositions.Add(block.Coord + new Int3(rotated.X - minX, rotated.Y, rotated.Z - minZ));
            }
        }

        foreach (var block in Map.GetBlocks())
        {
            if (!block.IsGround || !blockInfos.TryGetValue(block.Name, out var blockInfo) || blockInfo.Height is null)
            {
                continue;
            }

            if (groundPositions.Contains(block.Coord + (0, isManiaPlanet ? 0 : 1, 0)))
            {
                yield return block;
            }
        }
    }

    private IEnumerable<CGameCtnBlock> GetBaseZoneBlocks(BlockInfoDto? baseZoneInfo, int baseHeight)
    {
        if (Map is null || blockInfos is null || baseZoneInfo is null)
        {
            yield break;
        }

        var groundHeight = baseHeight + 1 + Map.DecoBaseHeightOffset;
        var occupied = new HashSet<(int X, int Z)>();

        foreach (var block in Map.GetBlocks())
        {
            if (!blockInfos.TryGetValue(block.Name, out var blockInfo) || blockInfo.Height.HasValue)
            {
                occupied.Add((block.Coord.X, block.Coord.Z));
                continue;
            }

            var units = block.IsGround ? blockInfo.GroundUnits : blockInfo.AirUnits;

            Span<Int3> rotatedUnits = stackalloc Int3[units.Length];

            // Determine minimum X and Z after rotation.
            var minX = int.MaxValue;
            var minZ = int.MaxValue;
            for (int i = 0; i < units.Length; i++)
            {
                var rotated = RotateUnit(units[i].Offset, block.Direction);
                rotatedUnits[i] = rotated;
                if (rotated.X < minX) minX = rotated.X;
                if (rotated.Z < minZ) minZ = rotated.Z;
            }

            // Adjust positions so the minimum X and Z become 0.
            foreach (var rotated in rotatedUnits)
            {
                var unit = block.Coord + new Int3(rotated.X - minX, rotated.Y, rotated.Z - minZ);
                if (unit.Y == groundHeight)
                {
                    occupied.Add((unit.X, unit.Z));
                }
            }
        }

        // Iterate through the entire zone; if a coordinate isn't occupied, yield a new block.
        for (int x = 0; x < Map.Size.X; x++)
        {
            for (int z = 0; z < Map.Size.Z; z++)
            {
                if (!occupied.Contains((x, z)))
                {
                    yield return new CGameCtnBlock
                        {
                            Name = baseZoneInfo.Name,
                            Coord = new Int3(x, groundHeight - 1, z),
                            Direction = Direction.North,
                            IsGround = true
                        };
                }
            }
        }
    }

    private static Int3 RotateUnit(Int3 unit, Direction direction) => direction switch
    {
        Direction.East => new Int3(-unit.Z, unit.Y, unit.X),
        Direction.South => new Int3(-unit.X, unit.Y, -unit.Z),
        Direction.West => new Int3(unit.Z, unit.Y, -unit.X),
        _ => unit,
    };

    public ValueTask DisposeAsync()
    {
        cts.Dispose();

        if (RendererInfo.IsInteractive)
        {
            Renderer.Dispose();
        }
        
        scene = null;
        camera = null;

        rendererModule?.Dispose();
        sceneModule?.Dispose();
        cameraModule?.Dispose();
        solidModule?.Dispose();
        materialModule?.Dispose();

        return ValueTask.CompletedTask;
    }
}